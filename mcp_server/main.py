# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:34:14+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyQuery, BaseSecurity
from fastapi import Path, Query
from pydantic import conint

from models import Ext, Ext1, GeometriesZoom, VersionNumber, View
from models.Search_versionNumber_GeometryFilter import FieldExtPostRequest
from models.Search_versionNumber_GeometrySearch_query_ import FieldExtPostRequest
from models.Search_versionNumber_RoutedFilter_position__heading_ import (
    FieldExtPostRequest,
)
from models.Search_versionNumber_SearchAlongRoute_query_ import FieldExtPostRequest

app = MCPProxy(
    contact={
        'name': 'Contact Us',
        'url': 'https://developer.tomtom.com/contact-us',
        'x-twitter': 'TomTom',
    },
    description='Search API is a RESTful API that allows developers to run a single line fuzzy search for addresses and POIs. Search API returns the latitude/longitude of a specific address, cross street, geographic feature, or point of interest (POI).',
    title='Search',
    version='1.0.0',
    servers=[{'url': 'https://api.tomtom.com'}],
)


@app.get(
    '/search/{versionNumber}/additionalData.{ext}',
    tags=['geometry_processing', 'search_operations'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_additional_data__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    ext: Ext = ...,
    geometries: str = ...,
    geometries_zoom: Optional[GeometriesZoom] = Query(None, alias='geometriesZoom'),
):
    """
    Additional Data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/cS/{category}.{ext}',
    tags=['search_operations', 'points_of_interest_search', 'geometry_processing'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_c_s__category__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    category: str = ...,
    ext: Ext1 = ...,
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius: Optional[int] = None,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    idx_set: Optional[str] = Query(None, alias='idxSet'),
    view: Optional[View] = 'Unified',
):
    """
    Low Bandwith Category Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/categorySearch/{query}.{ext}',
    tags=['search_operations', 'points_of_interest_search', 'geometry_processing'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_category_search__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius: Optional[int] = None,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    view: Optional[View] = 'Unified',
):
    """
    Category Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/geocode/{query}.{ext}',
    tags=['search_operations', 'points_of_interest_search', 'geocoding_tasks'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_geocode__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    store_result: Optional[bool] = Query(False, alias='storeResult'),
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius: Optional[int] = None,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    view: Optional[View] = 'Unified',
):
    """
    Geocode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/geometryFilter.{ext}',
    tags=['geometry_processing', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_geometry_filter__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    ext: Ext1 = ...,
    geometry_list: str = Query(..., alias='geometryList'),
    poi_list: str = Query(..., alias='poiList'),
):
    """
    Geometry Filter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/search/{versionNumber}/geometryFilter.{ext}',
    tags=['geometry_processing'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def post_search__version_number_geometry_filter__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    ext: Ext1 = ...,
    body: FieldExtPostRequest = None,
):
    """
    Geometry Filter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/geometrySearch/{query}.{ext}',
    tags=['search_operations', 'geometry_processing', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_geometry_search__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    geometry_list: Optional[str] = Query(None, alias='geometryList'),
    limit: Optional[conint(le=100)] = 10,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    idx_set: Optional[str] = Query(None, alias='idxSet'),
):
    """
    Geometry Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/search/{versionNumber}/geometrySearch/{query}.{ext}',
    tags=['search_operations', 'geometry_processing', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def post_search__version_number_geometry_search__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    limit: Optional[conint(le=100)] = 10,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    idx_set: Optional[str] = Query(None, alias='idxSet'),
    body: FieldExtPostRequest = None,
):
    """
    Geometry Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/nearbySearch/.{ext}',
    tags=['search_operations', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_nearby_search___ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    ext: Ext1 = ...,
    lat: float = ...,
    lon: float = ...,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    radius: Optional[conint(le=50000)] = 10000,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    min_fuzzy_level: Optional[conint(ge=1, le=4)] = Query(1, alias='minFuzzyLevel'),
    max_fuzzy_level: Optional[conint(ge=1, le=4)] = Query(2, alias='maxFuzzyLevel'),
    idx_set: Optional[str] = Query(None, alias='idxSet'),
    view: Optional[View] = 'Unified',
):
    """
    Nearby Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/poiSearch/{query}.{ext}',
    tags=['search_operations', 'points_of_interest_search', 'geocoding_tasks'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_poi_search__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius: Optional[int] = None,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    view: Optional[View] = 'Unified',
):
    """
    Points of Interest Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/reverseGeocode/crossStreet/{position}.{ext}',
    tags=[
        'search_operations',
        'routing_queries',
        'points_of_interest_search',
        'geocoding_tasks',
    ],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def cross_street_lookup(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    position: str = ...,
    ext: Ext1 = ...,
    limit: Optional[conint(ge=0, le=100)] = 1,
    spatial_keys: Optional[bool] = Query(False, alias='spatialKeys'),
    heading: Optional[float] = None,
    radius: Optional[int] = 10000,
    language: Optional[str] = None,
):
    """
    Cross Street lookup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/reverseGeocode/{position}.{ext}',
    tags=['search_operations', 'geocoding_tasks'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_reverse_geocode__position__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    position: str = ...,
    ext: Ext1 = ...,
    spatial_keys: Optional[bool] = Query(False, alias='spatialKeys'),
    return_speed_limit: Optional[bool] = Query(False, alias='returnSpeedLimit'),
    heading: Optional[float] = None,
    radius: Optional[int] = 10000,
    number: Optional[str] = None,
    return_road_use: Optional[bool] = Query(False, alias='returnRoadUse'),
    road_use: Optional[str] = Query(None, alias='roadUse'),
    callback: Optional[str] = 'cb',
):
    """
    Reverse Geocode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/routedFilter/{position}/{heading}.{ext}',
    tags=['routing_queries', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_routed_filter__position__heading__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    position: str = ...,
    heading: float = ...,
    ext: Ext1 = ...,
    poi_list: str = Query(..., alias='poiList'),
    routing_timeout: Optional[int] = Query(4000, alias='routingTimeout'),
):
    """
    Routed Filter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/search/{versionNumber}/routedFilter/{position}/{heading}.{ext}',
    tags=['routing_queries', 'geometry_processing'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def routed_filter_handler(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    position: str = ...,
    heading: float = ...,
    ext: Ext1 = ...,
    routing_timeout: Optional[int] = Query(4000, alias='routingTimeout'),
    body: FieldExtPostRequest = None,
):
    """
    Routed Filter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/routedSearch/{query}/{position}/{heading}.{ext}',
    tags=['search_operations', 'routing_queries', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def routed_search_with_limits_and_options(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    position: str = ...,
    heading: float = ...,
    ext: Ext1 = ...,
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    multiplier: Optional[int] = 2,
    routing_timeout: Optional[int] = Query(4000, alias='routingTimeout'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    idx_set: Optional[str] = Query(None, alias='idxSet'),
):
    """
    Routed Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/s/{query}.{ext}',
    tags=['search_operations', 'points_of_interest_search', 'geocoding_tasks'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_s__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius: Optional[int] = None,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    idx_set: Optional[str] = Query(None, alias='idxSet'),
    view: Optional[View] = 'Unified',
):
    """
    Low bandwith Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/search/{query}.{ext}',
    tags=['search_operations', 'points_of_interest_search'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_search__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    typeahead: Optional[bool] = False,
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    country_set: Optional[str] = Query(None, alias='countrySet'),
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius: Optional[int] = None,
    top_left: Optional[str] = Query(None, alias='topLeft'),
    btm_right: Optional[str] = Query(None, alias='btmRight'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
    min_fuzzy_level: Optional[conint(ge=1, le=4)] = Query(1, alias='minFuzzyLevel'),
    max_fuzzy_level: Optional[conint(ge=1, le=4)] = Query(2, alias='maxFuzzyLevel'),
    idx_set: Optional[str] = Query(None, alias='idxSet'),
    view: Optional[View] = 'Unified',
):
    """
    Fuzzy Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/search/{versionNumber}/searchAlongRoute/{query}.{ext}',
    tags=['search_operations', 'routing_queries'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def post_search__version_number_search_along_route__query__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    query: str = ...,
    ext: Ext1 = ...,
    max_detour_time: conint(le=3600) = Query(..., alias='maxDetourTime'),
    limit: Optional[conint(le=100)] = 10,
    body: FieldExtPostRequest = None,
):
    """
    Along Route Search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/{versionNumber}/structuredGeocode.{ext}',
    tags=['search_operations', 'geocoding_tasks'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_search__version_number_structured_geocode__ext(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    ext: Ext1 = ...,
    country_code: str = Query(..., alias='countryCode'),
    limit: Optional[conint(le=100)] = 10,
    ofs: Optional[conint(le=1900)] = 0,
    street_number: Optional[str] = Query(None, alias='streetNumber'),
    street_name: Optional[str] = Query(None, alias='streetName'),
    cross_street: Optional[str] = Query(None, alias='crossStreet'),
    municipality: Optional[str] = None,
    municipality_subdivision: Optional[str] = Query(
        None, alias='municipalitySubdivision'
    ),
    country_tertiary_subdivision: Optional[str] = Query(
        None, alias='countryTertiarySubdivision'
    ),
    country_secondary_subdivision: Optional[str] = Query(
        None, alias='countrySecondarySubdivision'
    ),
    country_subdivision: Optional[str] = Query(None, alias='countrySubdivision'),
    postal_code: Optional[str] = Query(None, alias='postalCode'),
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[str] = Query(
        None, alias='extendedPostalCodesFor'
    ),
):
    """
    Structured Geocode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
